<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Talk to Amber AI</title>
    <!-- Chart.js libraries - ORDER MATTERS! -->
    <!-- 1) Chart.js core -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- 2) date-fns adapter for time scales -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@latest"></script>
    <!-- 3) Financial chart plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <!-- 4) Annotations plugin for watermark -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap');
        
        :root {
            --primary-color: #ff417a;
            --secondary-color: #ff7642;
            --accent-color: #ffcb42;
            --dark-color: #1a1a1a;
            --light-color: #f5f5f5;
            --chat-bg: rgba(0, 0, 0, 0.7);
            --user-message-bg: #ff417a;
            --ai-message-bg: rgba(255, 118, 66, 0.8);
            --border-color: #ff417a;
        }
        
        body {
            font-family: 'VT323', monospace;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            background-attachment: fixed;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            overflow: hidden;
        }
        
        .container {
            width: 95%;
            max-width: 1400px;
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 90vh;
            border: 3px solid var(--border-color);
            position: relative;
            animation: fadeIn 0.8s ease;
        }
        
        .header {
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            text-align: center;
            border-bottom: 3px solid var(--border-color);
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            font-family: 'Press Start 2P', monospace;
            letter-spacing: 1px;
            text-transform: lowercase;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.7);
            animation: glowText 3s infinite alternate;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        .side-panel {
            width: 35%;
            display: flex;
            flex-direction: column;
        }
        
        .amber-avatar {
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            border-right: 3px solid var(--border-color);
            position: relative;
            z-index: 1;
            flex: 1;
        }
        
        .chart-display {
            height: 0;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.7);
            transition: height 0.5s ease;
            border-top: 3px solid var(--border-color);
            border-right: 3px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 15px;
        }
        
        .chart-display.active {
            height: 50%;
            padding: 15px;
        }
        
        .chart-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .chart-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            color: var(--accent-color);
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.7);
        }
        
        .chart-subtitle {
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            text-align: center;
        }
        
        .time-zone-info {
            font-family: 'VT323', monospace;
            font-size: 10px;
            color: rgba(255, 203, 66, 0.9);
            margin-top: 2px;
            text-align: center;
            font-style: italic;
        }
        
        .avatar-container {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            border: 3px solid rgba(255, 255, 255, 0.2);
        }
        
        .avatar-container:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }
        
        .avatar-img {
            width: 100%;
            display: block;
            object-fit: cover;
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .avatar-text {
            font-family: 'Press Start 2P', monospace;
            font-size: 22px;
            font-weight: bold;
            margin-top: 20px;
            color: var(--primary-color);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 1);
            animation: pulse 2s infinite;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            scroll-behavior: smooth;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ff417a' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        .messages::-webkit-scrollbar {
            width: 8px;
        }
        
        .messages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .messages::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 10px;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 12px 18px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            animation: messageFadeIn 0.5s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
        }
        
        .user-message {
            background-color: var(--user-message-bg);
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 0;
            font-size: 18px;
        }
        
        .amber-message {
            background-color: var(--ai-message-bg);
            align-self: flex-start;
            border-bottom-left-radius: 0;
            font-size: 18px;
            position: relative;
        }
        
        .input-area {
            display: flex;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            border-top: 3px solid var(--border-color);
            position: relative;
            z-index: 2;
        }
        
        #message-input {
            flex: 1;
            padding: 15px;
            border-radius: 30px;
            border: 2px solid var(--primary-color);
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        
        #message-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 12px rgba(255, 203, 66, 0.4);
        }
        
        #send-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 15px 25px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 18px;
            font-family: 'Press Start 2P', monospace;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            text-transform: lowercase;
        }
        
        #send-button:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            text-decoration: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 10;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            border: 2px solid var(--primary-color);
            text-shadow: 1px 1px 0px #000;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }
        
        .back-button:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
        }
        
        .coin-data {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            margin-top: 10px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-color);
            align-self: stretch;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            animation: slideIn 0.5s ease;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }
        
        .coin-data::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 65, 122, 0.1), rgba(255, 118, 66, 0.1), rgba(255, 203, 66, 0.1));
            z-index: -1;
        }
        
        .coin-data h3 {
            margin-top: 0;
            color: var(--accent-color);
            font-family: 'Silkscreen', monospace;
            letter-spacing: 1px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.7);
        }
        
        .coin-data p {
            margin: 5px 0;
            font-size: 16px;
            font-family: 'VT323', monospace;
            font-size: 18px;
        }
        
        /* Loading indicators */
        .loading-dots {
            display: inline-block;
        }
        
        .loading-dots::after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }
        
        /* Grid background animation */
        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(255, 65, 122, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 65, 122, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: -1;
            animation: gridScroll 20s linear infinite;
            pointer-events: none;
        }
        
        /* Animations */
        @keyframes gridScroll {
            0% { background-position: 0 0; }
            100% { background-position: 20px 20px; }
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes messageFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes glowText {
            0%, 100% { text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.7); }
            50% { text-shadow: 3px 3px 10px var(--primary-color); }
        }
        
        /* Tablet and mobile adjustments */
        @media (max-width: 768px) {
            .container {
                width: 95%;
                height: 90vh;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .side-panel {
                width: 100%;
                height: 40%;
                min-height: 250px;
                max-height: 40%;
            }
            
            .amber-avatar {
                border-right: none;
                border-bottom: 3px solid var(--border-color);
            }
            
            .avatar-container {
                max-width: 150px;
            }
            
            .avatar-text {
                font-size: 16px;
                margin-top: 10px;
            }
            
            .back-button {
                top: 10px;
                left: 10px;
                padding: 8px 15px;
                font-size: 10px;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .chart-display.active {
                height: calc(60% - 30px);
                max-height: 250px;
            }
            
            .chat-container {
                min-height: 200px;
                flex: 1;
            }
            
            .input-area {
                padding: 10px;
                position: relative;
                z-index: 10;
            }
            
            #message-input {
                padding: 10px;
                font-size: 16px;
                height: 40px;
            }
            
            #send-button {
                padding: 10px 15px;
                font-size: 14px;
                height: 40px;
                min-width: 70px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .messages {
                padding: 10px;
            }
            
            .message {
                padding: 8px 12px;
                font-size: 16px;
                max-width: 85%;
            }
        }
        
        /* Additional mobile optimizations for very small screens */
        @media (max-width: 480px) {
            .container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }
            
            .side-panel {
                height: 35%;
                min-height: 200px;
            }
            
            .avatar-container {
                max-width: 120px;
            }
            
            .avatar-text {
                font-size: 14px;
            }
            
            #message-input {
                font-size: 16px;
            }
            
            #send-button {
                font-size: 12px;
                padding: 10px;
                min-width: 60px;
            }
            
            .message {
                font-size: 16px;
                max-width: 90%;
            }
            
            body {
                overflow: hidden;
            }
        }
        
        /* Neon glow effects */
        .neon-glow {
            filter: drop-shadow(0 0 5px var(--primary-color));
        }
        
        .sparkle {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: sparkle 2s linear infinite;
            z-index: 1;
            opacity: 0.7;
        }
        
        @keyframes sparkle {
            0%, 100% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1); opacity: 0.7; }
        }
    </style>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon (2).png">
    <link rel="shortcut icon" type="image/png" href="favicon (2).png">
</head>
<body>
    <div class="grid-background"></div>
    <a href="index.html" class="back-button">back to home</a>
    
    <div class="container">
        <div class="header">
            <h1>talk to amber ai</h1>
        </div>
        
        <div class="main-content">
            <div class="side-panel">
                <div class="amber-avatar">
                    <div class="avatar-container">
                        <img id="avatar" src="images/idle animation.gif" alt="Amber AI" class="avatar-img">
                    </div>
                    <div class="avatar-text">amber</div>
                </div>
                <div id="chart-display" class="chart-display">
                    <div class="chart-title" id="inline-chart-title">Market Cap Data</div>
                    <div class="chart-container">
                        <canvas id="inline-chart"></canvas>
                    </div>
                    <div class="chart-subtitle" id="inline-chart-subtitle">Data provided by CoinGecko API</div>
                    <div class="time-zone-info" id="time-zone-info">Times shown in your local time zone</div>
                </div>
            </div>
            
            <div class="chat-container">
                <div id="messages" class="messages">
                    <!-- Messages will be added here -->
                    <div class="message amber-message">
                        hi there! i'm amber. i can help you check crypto tokens and analyze memes... or whatever. just ask me about any crypto or meme i guess.
                    </div>
                </div>
                
                <div class="input-area">
                    <input type="text" id="message-input" placeholder="ask me about crypto or whatever...">
                    <button id="send-button">send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Globals
        const avatar = document.getElementById('avatar');
        const messagesContainer = document.getElementById('messages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const chartDisplay = document.getElementById('chart-display');
        const inlineChart = document.getElementById('inline-chart');
        const inlineChartTitle = document.getElementById('inline-chart-title');
        const inlineChartSubtitle = document.getElementById('inline-chart-subtitle');
        
        // OpenAI API Key
        const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
        
        // Token registry
        const registeredTokens = {};
        
        // CoinGecko ID mapping for common tokens
        const COINGECKO_ID = {
            'BTC': 'bitcoin',
            'ETH': 'ethereum',
            'SOL': 'solana',
            'DOGE': 'dogecoin',
            'SHIB': 'shiba-inu',
            'PEPE': 'pepe',
            'XRP': 'ripple',
            'ADA': 'cardano',
            'AVAX': 'avalanche-2',
            'DOT': 'polkadot',
            'MATIC': 'matic-network',
            'LINK': 'chainlink',
            'UNI': 'uniswap',
            'AAVE': 'aave',
            'LTC': 'litecoin',
            'ATOM': 'cosmos',
            'FTM': 'fantom'
            // Add more mappings as needed
        };
        
        // Global CoinGecko lookup table - Seed with DARK upfront
        let cgLookup = {
            'DARK': 'dark-eclipse'
        };
        
        // GIFs for different states
        const GIFs = {
            idle: 'images/idle animation.gif',
            thinking: 'images/thinking gif.gif',
            stern: 'images/stern gif.gif',
            angry: 'images/angry gif.gif',
            sad: 'images/sad gif.gif',
            shy: 'images/shy gif.gif'
        };
        
        // Register the datalabels plugin globally
        Chart.register(ChartDataLabels);
        
        // Global references to charts
        let inlineSideChart = null;
        
        /**
         * Strip all emoji characters from a string.
         * @param {string} text
         * @returns {string}
         */
        function stripEmojis(text) {
            return text.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|[\uD83C-\uDBFF][\uDC00-\uDFFF]|[\uFE0F])/g, '');
        }
        
        // Close modal functions (defined BEFORE they are wired to event listeners)
        function closeModal() {
            // Check which modal is open
            if (document.getElementById('candle-modal').style.display === 'block') {
                document.getElementById('candle-modal').style.display = 'none';
                document.getElementById('modal-overlay').style.display = 'none';
                
                // Re-enable the message input
                messageInput.disabled = false;
                sendButton.disabled = false;
                
                // Add a message from Amber
                addMessage(`closed the chart. anything else you want to know?`, 'amber');
                
                // Return to idle state
                changeAvatar('idle');
                
                // Focus back on the input
                setTimeout(() => messageInput.focus(), 100);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Set up event listeners
            sendButton.addEventListener('click', handleUserMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleUserMessage();
                }
            });
            
            // Set up modal close button
            document.getElementById('close-modal-btn').addEventListener('click', closeModal);
            
            // Add click event to modal overlay for closing
            document.getElementById('modal-overlay').addEventListener('click', closeModal);
            
            // Add escape key support for closing modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (document.getElementById('candle-modal').style.display === 'block') {
                        closeModal();
                    }
                }
            });
            
            // Preload GIFs
            for (const gif in GIFs) {
                const img = new Image();
                img.src = GIFs[gif];
            }
            
            // Focus the input field on load
            setTimeout(() => {
                messageInput.focus();
            }, 500);
            
            // Run a quick Chart.js self-test to verify it's working
            testChartJS();
            
            // Initialize CoinGecko lookup table
            initCoinGeckoLookup();
            
            // Update time zone info
            updateTimeZoneInfo();
        });
        
        // Initialize CoinGecko lookup table
        async function initCoinGeckoLookup() {
            try {
                const res = await fetch('https://api.coingecko.com/api/v3/coins/list');
                if (!res.ok) throw new Error('CG list fetch failed: ' + res.status);
                const list = await res.json(); // array of { id, symbol, name }
                // map SYMBOL uppercase to id
                list.forEach(c => { cgLookup[c.symbol.toUpperCase()] = c.id });
                console.log('✅ CoinGecko lookup ready:', Object.keys(cgLookup).length, 'entries');
                
                // Note: DARK is already seeded in the lookup table at the top of the script
            } catch (e) {
                console.error('❌ initCoinGeckoLookup error:', e);
                console.warn('⚠️ Could not fetch full CG list, but DARK is still mapped');
            }
        }
        
        // Quick Chart.js test to verify it's working
        function testChartJS() {
            try {
                console.log("Testing Chart.js library setup...");
                
                // Create a hidden test canvas
                const testCanvas = document.createElement('canvas');
                testCanvas.style.position = 'absolute';
                testCanvas.style.top = '-9999px';
                testCanvas.style.left = '-9999px';
                testCanvas.width = 100;
                testCanvas.height = 100;
                document.body.appendChild(testCanvas);
                
                // Create test data
                const testData = [
                    { x: Date.now() - 3600000, o: 1, h: 1.2, l: 0.8, c: 1.1 },
                    { x: Date.now(), o: 1.1, h: 1.3, l: 1.0, c: 1.25 }
                ];
                
                // Try to create a test chart
                new Chart(testCanvas.getContext('2d'), {
                    type: 'candlestick',
                    data: { 
                        datasets: [{
                            label: 'Test',
                            data: testData
                        }]
                    },
                    options: {
                        scales: { 
                            x: { type: 'time' }, 
                            y: { beginAtZero: false } 
                        }
                    }
                });
                
                console.log("Chart.js test successful! Library is working properly.");
                
                // Remove test canvas after 2 seconds
                setTimeout(() => {
                    document.body.removeChild(testCanvas);
                }, 2000);
            } catch (error) {
                console.error("Chart.js test failed:", error);
            }
        }
        
        // Handle user messages
        async function handleUserMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, 'user');
            messageInput.value = '';
            
            // Show thinking state
            changeAvatar('thinking');
            
            // Add a small delay to simulate thinking
            await new Promise(resolve => setTimeout(resolve, 500));
            
            try {
                // Check if the user is asking for a memecoin idea
                if (message.toLowerCase().includes('memecoin idea') || 
                    message.toLowerCase().includes('meme coin idea') ||
                    (message.toLowerCase().includes('idea') && message.toLowerCase().includes('coin')) ||
                    (message.toLowerCase().includes('give me a') && message.toLowerCase().includes('coin'))) {
                    
                    // Check if they want no emojis
                    const removeEmojis = message.toLowerCase().includes('no emoji') || 
                                        message.toLowerCase().includes('without emoji') ||
                                        message.toLowerCase().includes('clean');
                    
                    // Generate memecoin idea
                    const memecoinIdea = await generateMemecoinIdea(removeEmojis);
                    
                    // Add the memecoin idea as a response
                    addMessage(memecoinIdea, 'amber');
                    
                    // Update avatar based on emotion and return
                    changeAvatar('shy');
                    setTimeout(() => changeAvatar('idle'), 5000);
                    return;
                }
                
                // Check if the message looks like a token address
                if (looksLikeAddress(message)) {
                    try {
                        const tokenInfo = await registerToken(message);
                        changeAvatar('idle');
                        
                        // Display token info
                        const formattedPrice = parseFloat(tokenInfo.price).toFixed(6);
                        let response = `cool, i found that token:\n`;
                        response += `${tokenInfo.symbol.toLowerCase()} on ${tokenInfo.chain}\n`;
                        response += `price: $${formattedPrice}\n\n`;
                        
                        // Add buy recommendation
                        if (tokenInfo.recommendation) {
                            response += `${tokenInfo.recommendation.result}`;
                        }
                        
                        addMessage(response, 'amber');
                        
                        // Add detailed token data in card format
                        addCoinData({
                            name: tokenInfo.name || tokenInfo.symbol,
                            symbol: tokenInfo.symbol,
                            price: formattedPrice,
                            marketCap: formatMarketCap(tokenInfo.marketCap || 0),
                            priceChange: tokenInfo.priceChange || '0.00',
                            isBitcoin: false,
                            recommendation: tokenInfo.recommendation
                        });
                        
                        // Show market cap chart in the side panel
                        showInlineChart(tokenInfo.symbol, tokenInfo.name);
                        
                        return;
                    } catch (error) {
                        console.error('Token registration error:', error);
                        changeAvatar('stern');
                        addMessage("hmm, i couldn't find that token address. double-check it maybe?", 'amber');
                        
                        // Return to idle after 3 seconds
                        setTimeout(() => {
                            changeAvatar('idle');
                        }, 3000);
                        
                        return;
                    }
                }
                
                // Check if message is asking about crypto
                if (isCryptoQuery(message)) {
                    const coinInfo = await getCryptoInfo(message);
                    if (coinInfo) {
                        // Generate crypto-focused response
                        let response;
                        if (isBitcoin(message)) {
                            response = `here's the latest bitcoin data. check out the chart i put on the side for you.`;
                        } else {
                            response = `found info on ${coinInfo.symbol.toLowerCase()}. i'm showing the chart on the side for you.`;
                        }
                        
                        // Add response first
                        addMessage(response, 'amber');
                        
                        // Then add the coin data
                        addCoinData(coinInfo);
                        
                        // Show chart in side panel
                        showInlineChart(coinInfo.symbol, coinInfo.name);
                        
                        // Update avatar based on emotion
                        changeAvatar(determineEmotion(message));
                        
                        // Return to idle after a few seconds
                        setTimeout(() => {
                            changeAvatar('idle');
                        }, 5000);
                        
                        return; // Skip the regular response generation
                    }
                }
                
                // Generate AI response for non-crypto queries
                const response = await generateResponse(message);
                
                // Update avatar based on emotion
                changeAvatar(determineEmotion(message));
                
                // Add AI response to chat
                addMessage(response, 'amber');
                
                // Calculate display time based on message length (at least 2 seconds, max 10 seconds)
                const displayTime = Math.min(Math.max(2000, response.length * 50), 10000);
                
                // Return to idle after a delay proportional to message length
                setTimeout(() => {
                    changeAvatar('idle');
                }, displayTime);
                
            } catch (error) {
                console.error('Error:', error);
                addMessage("ugh, something broke... not my fault tho. try again maybe?", 'amber');
                changeAvatar('sad');
                
                // Return to idle after 3 seconds
                setTimeout(() => {
                    changeAvatar('idle');
                }, 3000);
            }
        }
        
        // Add a message to the chat
        function addMessage(text, sender) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(sender === 'user' ? 'user-message' : 'amber-message');
            messageElement.textContent = text;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Add a little animation effect
            setTimeout(() => {
                messageElement.style.opacity = '1';
                messageElement.style.transform = 'translateY(0)';
            }, 10);
        }
        
        // Add coin data to the chat
        function addCoinData(coinInfo) {
            const coinElement = document.createElement('div');
            coinElement.classList.add('coin-data');
            coinElement.classList.add('neon-glow');
            const coinId = Date.now().toString(); // Generate unique ID for the charts
            
            let coinHTML = `
                <h3>${coinInfo.name.toLowerCase()} (${coinInfo.symbol.toLowerCase()})</h3>
                <p>price: $${coinInfo.price}</p>`;
                
            // Only show market cap if it's not Bitcoin
            if (!coinInfo.isBitcoin && coinInfo.marketCap) {
                coinHTML += `<p>market cap: $${coinInfo.marketCap}</p>`;
            }
            
            coinHTML += `<p>24h change: ${coinInfo.priceChange}%</p>`;
            
            // Add recommendation if available
            if (coinInfo.recommendation) {
                const recommendationColor = coinInfo.recommendation.sentiment === 'positive' ? '#00cc66' : 
                                           coinInfo.recommendation.sentiment === 'negative' ? '#ff3366' : '#ffcc00';
                                           
                coinHTML += `<p style="margin-top: 10px; color: ${recommendationColor};">
                    <strong>analysis:</strong> ${coinInfo.recommendation.result}
                </p>`;
            }
            
            // Add sparkline chart
            coinHTML += `
                <div class="chart-container" style="width:150px; height:50px; cursor:pointer; margin-top: 15px;">
                    <canvas id="sparkline-${coinId}"></canvas>
                </div>
                <p style="font-size: 10px; margin-top: 5px; opacity: 0.7;">check out the full chart on the side panel</p>
            `;
            
            coinElement.innerHTML = coinHTML;
            messagesContainer.appendChild(coinElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Generate demo price data for the chart (since we may not have real data)
            const demoData = generateDemoPriceData(coinInfo.price, coinInfo.priceChange);
            drawSparkline(coinId, demoData, coinInfo.priceChange < 0);
        }
        
        // Generate demo price data for charts
        function generateDemoPriceData(currentPrice, percentChange) {
            const points = 24; // 24 hours of data
            const data = [];
            const price = parseFloat(currentPrice);
            const startPrice = price * 100 / (100 + parseFloat(percentChange));
            
            // Create data points with a natural curve
            for (let i = 0; i < points; i++) {
                // Calculate time (24 hours ago to now)
                const time = Date.now() - (points - i) * 3600 * 1000;
                
                // Interpolate price with some randomness
                let progress = i / points;
                let randomFactor = 0.5 - Math.random();
                let currentPoint = startPrice + (price - startPrice) * progress + (randomFactor * price * 0.02);
                
                data.push({
                    t: time,
                    y: currentPoint
                });
            }
            
            return data;
        }
        
        // Draw price sparkline
        function drawSparkline(id, prices, isNegative) {
            setTimeout(() => {
                const ctx = document.getElementById(`sparkline-${id}`)?.getContext('2d');
                if (!ctx) return;
                
                new Chart(ctx, {
                    type: 'line',
                    data: { 
                        datasets: [{
                            data: prices,
                            borderWidth: 2,
                            pointRadius: 0,
                            borderColor: isNegative ? '#ff3366' : '#00cc66',
                            backgroundColor: isNegative ? 'rgba(255, 51, 102, 0.1)' : 'rgba(0, 204, 102, 0.1)',
                            fill: true
                        }]
                    },
                    options: {
                        animation: false,
                        scales: { x: { display: false }, y: { display: false } },
                        elements: { line: { tension: 0.3 } },
                        plugins: { 
                            legend: { display: false }, 
                            tooltip: { enabled: false },
                            datalabels: false // Explicitly disable datalabels
                        }
                    }
                });
            }, 100); // Slight delay to ensure canvas is ready
        }
        
        // Global reference to candlestick chart
        let candleChart;
        
        // Show candlestick chart in modal (SIMULATED DATA)
        function showCandleChart(symbol, name) {
            // Disable message input while chart is open
            messageInput.disabled = true;
            sendButton.disabled = true;
            
            // Clean up existing chart if any
            if (candleChart) {
                candleChart.destroy();
            }
            
            // Update chart title with symbol and clear simulation indicator
            document.getElementById('chart-title').innerHTML = `${symbol.toUpperCase()} - ${name || 'Token'} Price (24h) <span style="font-size:0.6em; opacity:0.8;">(simulated data)</span>`;
            
            // Change avatar to thinking state
            changeAvatar('thinking');
            
            try {
                // Generate simulated OHLC data
                const tokenInfo = registeredTokens[symbol] || { price: '1.0', priceChange: '5.0' };
                const ohlc = generateOHLCData(symbol, tokenInfo.price, tokenInfo.priceChange);
                
                const ctx = document.getElementById('candle-chart').getContext('2d');
                candleChart = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: [{
                            label: symbol.toUpperCase(),
                            data: ohlc
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'hour' },
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                beginAtZero: false,
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            }
                        },
                        plugins: {
                            legend: { 
                                display: true, 
                                labels: { color: '#fff' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        return [
                                            'Open: $' + point.o.toFixed(6),
                                            'High: $' + point.h.toFixed(6),
                                            'Low: $' + point.l.toFixed(6),
                                            'Close: $' + point.c.toFixed(6)
                                        ];
                                    }
                                }
                            },
                            datalabels: false, // Disable datalabels for this chart
                            // Add a watermark to further emphasize this is simulated data
                            subtitle: {
                                display: true,
                                text: 'SIMULATED DATA',
                                color: 'rgba(255,255,255,0.1)',
                                font: {
                                    size: 30,
                                    family: 'monospace',
                                    weight: 'bold'
                                },
                                padding: {
                                    top: 50
                                }
                            }
                        }
                    }
                });
                
                // Show the modal and overlay
                document.getElementById('candle-modal').style.display = 'block';
                document.getElementById('modal-overlay').style.display = 'block';
                
            } catch (e) {
                console.error('Error generating chart:', e);
                addMessage(`sorry, i couldn't create a chart for ${symbol}. try another token?`, 'amber');
                changeAvatar('stern');
            } finally {
                // Return to idle state after a delay
                setTimeout(() => {
                    changeAvatar('idle');
                }, 1000);
            }
        }
        
        // Global reference to market cap chart
        let capChart;
        
        // Show market cap chart in modal (REAL DATA)
        async function showMarketCapChart(symbol, name) {
            // Disable message input while chart is open
            messageInput.disabled = true;
            sendButton.disabled = true;
            
            // Clean up existing chart if any
            if (capChart) {
                capChart.destroy();
            }
            
            // Update chart title with symbol
            document.getElementById('cap-chart-title').innerHTML = `${symbol.toUpperCase()} - ${name || 'Token'} <span style="font-size:0.6em; opacity:0.8;">(loading data...)</span>`;
            
            // Change avatar to thinking state
            changeAvatar('thinking');
            
            try {
                const data = await fetchMarketCapSeries(symbol);
                console.log('Market-cap data points:', data.length);
                // Log the data for debugging
                console.log('First few data points:', data.slice(0, 3));
                console.log('Min market cap:', Math.min(...data.map(d => d.y)));
                console.log('Max market cap:', Math.max(...data.map(d => d.y)));
                
                // Update chart title
                document.getElementById('cap-chart-title').innerHTML = `${symbol.toUpperCase()} - ${name || 'Token'} Market Cap (24h) <span style="font-size:0.6em; opacity:0.8;">(USD)</span>`;
                
                const ctx = document.getElementById('cap-chart').getContext('2d');
                capChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `${symbol.toUpperCase()} Market Cap`,
                            data,
                            pointRadius: 2,  // Add small point markers to make data visible
                            borderWidth: 3,  // Slightly thicker line
                            borderColor: '#ff417a',  // Use concrete hex color instead of CSS var
                            backgroundColor: 'rgba(255, 65, 122, 0.1)',
                            fill: true,
                            // Explicitly set parsing keys for chart.js to properly read data
                            parsing: {
                                xAxisKey: 't',
                                yAxisKey: 'y'
                            }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'hour', tooltipFormat: 'MMM d, h a' },
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                ticks: {
                                    color: '#ffffff',
                                    callback: val => {
                                        // Format with K/M suffix for more readable display
                                        if (val >= 1000000) {
                                            return '$' + (val/1000000).toFixed(2) + 'M';
                                        } else if (val >= 1000) {
                                            return '$' + (val/1000).toFixed(1) + 'K';
                                        } else {
                                            return '$' + val.toFixed(2);
                                        }
                                    }
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                // Calculate better min/max to show variations more dramatically
                                afterDataLimits: (scale) => {
                                    // Make the scale 10% narrower than auto to highlight changes
                                    const range = scale.max - scale.min;
                                    const middle = (scale.max + scale.min) / 2;
                                    scale.min = middle - range * 0.45;
                                    scale.max = middle + range * 0.45;
                                }
                            }
                        },
                        plugins: {
                            datalabels: false, // Explicitly disable datalabels
                            legend: { display: true, labels: { color: '#fff' } },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const v = ctx.parsed.y;
                                        // Format with K/M suffix in tooltips
                                        if (v >= 1000000) {
                                            return ` $${(v/1000000).toFixed(2)}M`;
                                        } else if (v >= 1000) {
                                            return ` $${(v/1000).toFixed(1)}K`;
                                        } else {
                                            return ` $${v.toFixed(2)}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Show modal message instead of showing the removed cap-modal
                addMessage(`Sorry, the X Token Guide feature is currently unavailable.`, 'amber');
                changeAvatar('stern');
                
            } catch (e) {
                console.error('Error fetching market cap data:', e);
                addMessage(`sorry, couldn't get market cap data for ${symbol}. try another token?`, 'amber');
                changeAvatar('stern');
            } finally {
                // Return to idle state after a delay
                setTimeout(() => {
                    changeAvatar('idle');
                }, 1000);
            }
        }
        
        // Resolver for CoinGecko IDs with fallback to search API
        async function resolveCoinGeckoID(symbol) {
            const up = symbol.toUpperCase();
            if (cgLookup[up]) return cgLookup[up];
          
            // Fallback: search CG by symbol/name
            try {
                const resp = await fetch(
                    `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(symbol)}`
                );
                if (!resp.ok) throw new Error(`Search failed: ${resp.status}`);
                const { coins } = await resp.json();
                if (!coins.length) throw new Error(`No match for "${symbol}"`);
              
                // prefer exact-symbol match
                let match = coins.find(c => c.symbol.toUpperCase() === up) || coins[0];
                cgLookup[up] = match.id;   // cache for next time
                console.log(`✅ Resolved "${symbol}" to CoinGecko ID "${match.id}"`);
                return match.id;
            } catch (e) {
                console.error(`❌ Failed to resolve "${symbol}":`, e);
                throw e;
            }
        }
        
        // Fetch market-cap series using resolver
        async function fetchMarketCapSeries(symbol) {
            try {
                const id = await resolveCoinGeckoID(symbol);
                const url = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(id)}/market_chart?vs_currency=usd&days=1`;
                console.log('⏳ Fetching market cap for', symbol, 'via', url);
                const resp = await fetch(url);
                if (!resp.ok) throw new Error(`Market-chart fetch failed: ${resp.status}`);
                const { market_caps } = await resp.json();
                console.log(`✅ Got ${market_caps.length} market cap data points for ${symbol}`);
                return market_caps.map(p => ({ t: p[0], y: p[1] }));
            } catch (e) {
                console.error('❌ fetchMarketCapSeries error:', e);
                throw e;
            }
        }

        // Change Amber's avatar
        function changeAvatar(state) {
            avatar.src = GIFs[state];
        }
        
        // Basic crypto query detection
        function isCryptoQuery(text) {
            const cryptoKeywords = ['coin', 'token', 'crypto', 'price', 'market cap', 'eth', 'btc', 'bitcoin', 'ethereum', '$'];
            const lowerText = text.toLowerCase();
            return cryptoKeywords.some(keyword => lowerText.includes(keyword));
        }
        
        // Determine emotional response based on message content
        function determineEmotion(text) {
            const lowerText = text.toLowerCase();
            
            // Check for compliments and nice things - shy response
            const compliments = ['cute', 'beautiful', 'pretty', 'nice', 'amazing', 'awesome', 'love', 'good job', 'well done', 'smart'];
            if (compliments.some(word => lowerText.includes(word))) {
                return 'shy';
            }
            
            // Check for offensive content - angry response
            const offensiveWords = ['fuck', 'shit', 'damn', 'ass', 'idiot', 'stupid', 'hate', 'kill', 'bitch'];
            if (offensiveWords.some(word => lowerText.includes(word))) {
                return 'angry';
            }
            
            // Check for negative content - sad response
            const negativeWords = ['sad', 'bad', 'terrible', 'awful', 'dislike', 'sorry', 'unfortunate', 'regret', 'depressed'];
            if (negativeWords.some(word => lowerText.includes(word))) {
                return 'sad';
            }
            
            // Check for serious/stern content
            const seriousWords = ['serious', 'important', 'critical', 'concern', 'worried', 'warning', 'careful', 'stop', 'danger'];
            if (seriousWords.some(word => lowerText.includes(word))) {
                return 'stern';
            }
            
            // Default to idle for neutral messages
            return 'idle';
        }
        
        // Generate response using OpenAI API
        async function generateResponse(message) {
            // For demo, we'll use a local response
            // In production, connect to OpenAI API
            const apiUrl = 'https://api.openai.com/v1/chat/completions';
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [
                            {
                                role: "system",
                                content: "You are Amber, a snarky AI assistant who specializes in cryptocurrency and meme analysis. You type in all lowercase with minimal punctuation and sometimes shortened words like 'idk' or 'lol'. Your tone is casual, slightly sarcastic, and cool but still informative. Provide concise responses about crypto tokens and current meme trends. Keep your personality consistent - you're knowledgeable but with an attitude. Always respond in English only, never in any other language even if the user asks in another language."
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        max_tokens: 150
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const data = await response.json();
                return data.choices[0].message.content.trim();
                
            } catch (error) {
                console.error('OpenAI API Error:', error);
                return "ugh, having trouble connecting to my brain rn... try again in a sec, k?";
            }
        }
        
        // Get crypto information from DexScreener API
        async function getCryptoInfo(query) {
            // Extract potential coin name or symbol
            const words = query.split(/\s+/);
            let coinQuery = '';
            
            // Look for words that might be coin names or symbols
            for (const word of words) {
                // Check if word starts with $ (common for crypto symbols)
                if (word.startsWith('$')) {
                    coinQuery = word.substring(1);
                    break;
                }
                
                // Check known coin names
                const knownCoins = ['bitcoin', 'ethereum', 'solana', 'bnb', 'doge', 'shib'];
                const lowerWord = word.toLowerCase();
                if (knownCoins.includes(lowerWord)) {
                    coinQuery = lowerWord;
                    break;
                }
            }
            
            // If no coin found in query, try to find any word that might be a coin
            if (!coinQuery) {
                for (const word of words) {
                    if (word.length >= 3 && /^[a-zA-Z0-9]+$/.test(word)) {
                        coinQuery = word;
                        break;
                    }
                }
            }
            
            if (!coinQuery) return null;
            
            // Check if this is a Bitcoin query
            const isBtcQuery = isBitcoin(coinQuery);
            
            // Special case for Bitcoin to ensure we never show market cap
            if (isBtcQuery) {
                try {
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true');
                    const data = await response.json();
                    
                    if (data && data.bitcoin) {
                        return {
                            name: 'Bitcoin',
                            symbol: 'BTC',
                            price: data.bitcoin.usd.toFixed(2),
                            marketCap: null, // Explicitly null
                            priceChange: data.bitcoin.usd_24h_change ? data.bitcoin.usd_24h_change.toFixed(2) : '0.00',
                            isBitcoin: true
                        };
                    }
                } catch (error) {
                    console.log('Fallback Bitcoin API error, continuing with regular API');
                }
            }
            
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(coinQuery)}`);
                const data = await response.json();
                
                if (data.pairs && data.pairs.length > 0) {
                    const pair = data.pairs[0];
                    return {
                        name: pair.baseToken.name || 'Unknown',
                        symbol: pair.baseToken.symbol || 'Unknown',
                        price: parseFloat(pair.priceUsd || 0).toFixed(6),
                        marketCap: isBtcQuery ? null : formatMarketCap(pair.marketCap || 0),
                        priceChange: pair.priceChange.h24 || '0.00',
                        isBitcoin: isBtcQuery
                    };
                }
                return null;
            } catch (error) {
                console.error('DexScreener API Error:', error);
                return null;
            }
        }
        
        // Format market cap with appropriate suffix (K, M, B)
        function formatMarketCap(marketCap) {
            if (!marketCap) return '0';
            
            marketCap = parseFloat(marketCap);
            
            if (marketCap >= 1e9) {
                return (marketCap / 1e9).toFixed(2) + 'B';
            } else if (marketCap >= 1e6) {
                return (marketCap / 1e6).toFixed(2) + 'M';
            } else if (marketCap >= 1e3) {
                return (marketCap / 1e3).toFixed(2) + 'K';
            } else {
                return marketCap.toFixed(2);
            }
        }
        
        // Check if a coin is Bitcoin
        function isBitcoin(name) {
            if (!name) return false;
            name = name.toLowerCase().trim();
            
            // Direct matches
            if (name === 'btc' || name === 'bitcoin' || name === 'xbt') return true;
            
            // Wrapped variants
            if (name === 'wbtc' || name === 'wrapped bitcoin') return true;
            
            // Partial matches
            if (name.includes('bitcoin') || name.includes(' btc') || name.startsWith('btc')) return true;
            
            return false;
        }
        
        // Check if a string looks like a token address
        function looksLikeAddress(input) {
            // Check for Solana or EVM address format
            return /^[A-Za-z0-9]{30,}$/.test(input.trim());
        }
        
        // Register a token by address
        async function registerToken(address, chain = 'solana') {
            // Try Solana first
            try {
                const url = `https://api.dexscreener.com/latest/dex/tokens/${address}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.pairs && data.pairs.length > 0) {
                    const pair = data.pairs[0];
                    const info = {
                        chain: pair.chainId || chain,
                        name: pair.baseToken.name,
                        symbol: pair.baseToken.symbol || pair.baseToken.name,
                        price: pair.priceUsd,
                        marketCap: pair.marketCap,
                        priceChange: pair.priceChange?.h24 || '0.00',
                        priceChange1h: pair.priceChange?.h1 || '0.00',
                        priceChange6h: pair.priceChange?.h6 || '0.00',
                        priceChange24h: pair.priceChange?.h24 || '0.00',
                        priceChange7d: pair.priceChange?.d7 || '0.00',
                        volume24h: pair.volume?.h24 || 0,
                        txns24h: pair.txns?.h24?.buys + pair.txns?.h24?.sells || 0,
                        liquidity: pair.liquidity?.usd || 0
                    };
                    
                    // Add recommendation
                    info.recommendation = recommendToken(info);
                    
                    // Store in registry
                    registeredTokens[address] = info;
                    return info;
                }
            } catch (error) {
                console.error('Error fetching token info:', error);
            }
            
            // If Solana fails, try Ethereum
            try {
                const ethUrl = `https://api.dexscreener.com/latest/dex/tokens/ethereum/${address}`;
                const ethResponse = await fetch(ethUrl);
                const ethData = await ethResponse.json();
                
                if (ethData.pairs && ethData.pairs.length > 0) {
                    const pair = ethData.pairs[0];
                    const info = {
                        chain: 'ethereum',
                        name: pair.baseToken.name,
                        symbol: pair.baseToken.symbol || pair.baseToken.name,
                        price: pair.priceUsd,
                        marketCap: pair.marketCap,
                        priceChange: pair.priceChange?.h24 || '0.00',
                        priceChange1h: pair.priceChange?.h1 || '0.00',
                        priceChange6h: pair.priceChange?.h6 || '0.00',
                        priceChange24h: pair.priceChange?.h24 || '0.00',
                        priceChange7d: pair.priceChange?.d7 || '0.00',
                        volume24h: pair.volume?.h24 || 0,
                        txns24h: pair.txns?.h24?.buys + pair.txns?.h24?.sells || 0,
                        liquidity: pair.liquidity?.usd || 0
                    };
                    
                    // Add recommendation
                    info.recommendation = recommendToken(info);
                    
                    // Store in registry
                    registeredTokens[address] = info;
                    return info;
                }
            } catch (error) {
                console.error('Error fetching Ethereum token info:', error);
            }
            
            throw new Error('No token found with that address');
        }
        
        // Recommend if a token is a buy or not
        function recommendToken(tokenInfo) {
            const {
                price, 
                marketCap, 
                priceChange1h, 
                priceChange6h, 
                priceChange24h,
                volume24h,
                liquidity
            } = tokenInfo;
            
            // Parse numeric values safely
            const numMarketCap = parseFloat(marketCap) || 0;
            const numPriceChange1h = parseFloat(priceChange1h) || 0;
            const numPriceChange6h = parseFloat(priceChange6h) || 0;
            const numPriceChange24h = parseFloat(priceChange24h) || 0;
            const numVolume24h = parseFloat(volume24h) || 0;
            const numLiquidity = parseFloat(liquidity) || 0;
            
            // Analysis criteria
            const results = {
                signals: {
                    recentDip: numPriceChange1h < -2,  // Recent 1h price drop > 2%
                    uptrend24h: numPriceChange24h > 3, // Up more than 3% in 24h
                    healthyMarketCap: numMarketCap > 1000000, // At least $1M market cap
                    goodLiquidity: numLiquidity > 50000, // At least $50K in liquidity
                    healthyVolume: numVolume24h > numMarketCap * 0.05, // Daily volume at least 5% of market cap
                    overheated: numPriceChange24h > 30, // More than 30% up in 24h is overheated
                    isMicrocap: numMarketCap < 500000, // Less than $500K is micro cap
                    isLowLiquidity: numLiquidity < 10000 // Less than $10K is low liquidity
                },
                result: '',
                sentiment: ''
            };
            
            // Determine overall recommendation
            if (results.signals.overheated) {
                results.result = '🔴 price is running hot—might want to wait for a pullback';
                results.sentiment = 'negative';
            } else if (results.signals.isMicrocap || results.signals.isLowLiquidity) {
                results.result = '⚠️ very small cap or low liquidity—proceed with extreme caution';
                results.sentiment = 'negative';
            } else if (results.signals.recentDip && results.signals.healthyMarketCap && results.signals.goodLiquidity) {
                results.result = '🟢 potential buy opportunity: healthy cap, decent liquidity, recent dip';
                results.sentiment = 'positive';
            } else if (results.signals.uptrend24h && !results.signals.recentDip && results.signals.healthyMarketCap) {
                results.result = '🟡 in uptrend but no recent dip—might want to wait for a better entry';
                results.sentiment = 'neutral';
            } else if (results.signals.healthyMarketCap && results.signals.goodLiquidity && results.signals.healthyVolume) {
                results.result = '🟢 looks decent: healthy market cap, liquidity, and volume';
                results.sentiment = 'positive';
            } else {
                results.result = '🟡 neutral—no clear signal either way';
                results.sentiment = 'neutral';
            }
            
            return results;
        }

        // Create a sparkline chart for token info
        function createSparkline(chartId, address, symbol, data) {
            const ctx = document.getElementById(chartId).getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [...Array(data.length).keys()], // Auto-gen sequential labels
                    datasets: [{
                        data: data,
                        borderColor: data[0] < data[data.length-1] ? '#32cd32' : '#ff6961',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    }
                }
            });
            
            // Add click event to sparkline parent to show market cap chart
            document.getElementById(chartId).parentElement.addEventListener('click', () => {
                showMarketCapChart(symbol);
            });
        }

        // Add sparkles
        function addSparkles() {
            const container = document.querySelector('.container');
            for (let i = 0; i < 15; i++) {
                const sparkle = document.createElement('div');
                sparkle.classList.add('sparkle');
                sparkle.style.width = Math.random() * 3 + 1 + 'px';
                sparkle.style.height = sparkle.style.width;
                sparkle.style.left = Math.random() * 100 + '%';
                sparkle.style.top = Math.random() * 100 + '%';
                sparkle.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(sparkle);
            }
        }

        // Add sparkles on load
        document.addEventListener('DOMContentLoaded', addSparkles);

        // Update time zone info
        function updateTimeZoneInfo() {
            const timeZoneElement = document.getElementById('time-zone-info');
            if (timeZoneElement) {
                const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const formattedZone = timeZone.replace(/\//g, ' / ').replace(/_/g, ' ');
                timeZoneElement.textContent = `Times shown in ${formattedZone} time zone`;
            }
        }

        // Show chart in the side panel
        async function showInlineChart(symbol, name) {
            try {
                // Clear any existing chart
                if (inlineSideChart) {
                    inlineSideChart.destroy();
                    inlineSideChart = null;
                }
                
                // Show the chart container
                chartDisplay.classList.add('active');
                
                // Update chart title
                inlineChartTitle.textContent = `${symbol.toUpperCase()} - ${name || 'Token'}`;
                inlineChartSubtitle.textContent = 'Loading market cap data...';
                
                // Update time zone info
                updateTimeZoneInfo();
                
                // Fetch market cap data
                const data = await fetchMarketCapSeries(symbol);
                
                // Update subtitle
                inlineChartSubtitle.textContent = 'Market Cap (USD) - CoinGecko API';
                
                // Create the chart
                const ctx = inlineChart.getContext('2d');
                inlineSideChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `${symbol.toUpperCase()} Market Cap`,
                            data,
                            pointRadius: 0,  // Hide point markers for cleaner look
                            borderWidth: 3,  // Slightly thicker line
                            borderColor: '#ff417a',  // Use concrete hex color instead of CSS var
                            backgroundColor: 'rgba(255, 65, 122, 0.1)',
                            fill: true,
                            // Explicitly set parsing keys for chart.js to properly read data
                            parsing: {
                                xAxisKey: 't',
                                yAxisKey: 'y'
                            }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'hour', tooltipFormat: 'MMM d, h a' },
                                ticks: { 
                                    color: '#ffffff',
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 6
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                ticks: {
                                    color: '#ffffff',
                                    callback: val => {
                                        // Format with K/M suffix for more readable display
                                        if (val >= 1000000) {
                                            return '$' + (val/1000000).toFixed(1) + 'M';
                                        } else if (val >= 1000) {
                                            return '$' + (val/1000).toFixed(1) + 'K';
                                        } else {
                                            return '$' + val.toFixed(0);
                                        }
                                    },
                                    maxTicksLimit: 5
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                // Calculate better min/max to show variations more dramatically
                                afterDataLimits: (scale) => {
                                    // Make the scale 20% narrower than auto to highlight changes
                                    const range = scale.max - scale.min;
                                    const middle = (scale.max + scale.min) / 2;
                                    scale.min = middle - range * 0.4;
                                    scale.max = middle + range * 0.4;
                                }
                            }
                        },
                        plugins: {
                            datalabels: false, // Explicitly disable datalabels
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const v = ctx.parsed.y;
                                        // Format with K/M suffix in tooltips
                                        if (v >= 1000000) {
                                            return ` $${(v/1000000).toFixed(2)}M`;
                                        } else if (v >= 1000) {
                                            return ` $${(v/1000).toFixed(1)}K`;
                                        } else {
                                            return ` $${v.toFixed(2)}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error showing inline chart:', error);
                inlineChartSubtitle.textContent = 'Could not load data. Try another token.';
                
                // Create empty chart with error message
                const ctx = inlineChart.getContext('2d');
                inlineSideChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'No data available',
                            data: [],
                            borderColor: '#ff417a'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { display: true, ticks: { color: '#ffffff' } },
                            y: { display: true, ticks: { color: '#ffffff' } }
                        },
                        plugins: {
                            datalabels: false,
                            legend: { display: false }
                        }
                    }
                });
            }
        }

        // Generate memecoin idea using OpenAI
        async function generateMemecoinIdea(removeEmojis = false) {
            const apiUrl = 'https://api.openai.com/v1/chat/completions';
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [
                            {
                                role: "system",
                                content: "You are Amber, a snarky AI assistant who specializes in cryptocurrency and meme analysis. You type in all lowercase with minimal punctuation and sometimes shortened words like 'idk' or 'lol'. Your tone is casual, slightly sarcastic, and cool but still informative. You're creative and wildly good at coming up with memecoin ideas."
                            },
                            {
                                role: "user",
                                content: "Give me a creative and fun memecoin idea. Include: 1) Name & ticker, 2) A one-line theme or joke, 3) Simple tokenomics (supply & distribution), 4) A catchy marketing hook. Format it nicely with emojis and keep it in character as Amber."
                            }
                        ],
                        max_tokens: 300
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const data = await response.json();
                const ideaText = data.choices[0].message.content.trim();
                
                // Check if we should strip emojis
                return removeEmojis ? stripEmojis(ideaText) : ideaText;
                
            } catch (error) {
                console.error('OpenAI API Error for memecoin idea:', error);
                return "ugh, my creative brain is glitching rn... ask me again in a bit and i might have something cool for u";
            }
        }
    </script>
</body>
</html> 